import typing
from marshmallow import types as types
from marshmallow.exceptions import ValidationError as ValidationError
from typing import Any

class Validator:
    error: typing.Optional[str] = ...

class URL(Validator):
    class RegexMemoizer:
        def __init__(self) -> None: ...
        def __call__(self, relative: bool, require_tld: bool) -> typing.Pattern: ...
    default_message: str = ...
    default_schemes: Any = ...
    relative: Any = ...
    error: Any = ...
    schemes: Any = ...
    require_tld: Any = ...
    def __init__(self, *, relative: bool=..., schemes: types.StrSequenceOrSet=..., require_tld: bool=..., error: str=...) -> None: ...
    def __call__(self, value: Any) -> typing.Any: ...

class Email(Validator):
    USER_REGEX: Any = ...
    DOMAIN_REGEX: Any = ...
    DOMAIN_WHITELIST: Any = ...
    default_message: str = ...
    error: Any = ...
    def __init__(self, *, error: str=...) -> None: ...
    def __call__(self, value: Any) -> typing.Any: ...

class Range(Validator):
    message_min: str = ...
    message_max: str = ...
    message_all: str = ...
    message_gte: str = ...
    message_gt: str = ...
    message_lte: str = ...
    message_lt: str = ...
    min: Any = ...
    max: Any = ...
    error: Any = ...
    min_inclusive: Any = ...
    max_inclusive: Any = ...
    def __init__(self, min: Any=..., max: Any=..., *, min_inclusive: bool=..., max_inclusive: bool=..., error: str=...) -> None: ...
    def __call__(self, value: Any) -> typing.Any: ...

class Length(Validator):
    message_min: str = ...
    message_max: str = ...
    message_all: str = ...
    message_equal: str = ...
    min: Any = ...
    max: Any = ...
    error: Any = ...
    equal: Any = ...
    def __init__(self, min: int=..., max: int=..., *, equal: int=..., error: str=...) -> None: ...
    def __call__(self, value: Any) -> typing.Any: ...

class Equal(Validator):
    default_message: str = ...
    comparable: Any = ...
    error: Any = ...
    def __init__(self, comparable: Any, *, error: str=...) -> None: ...
    def __call__(self, value: Any) -> typing.Any: ...

class Regexp(Validator):
    default_message: str = ...
    regex: Any = ...
    error: Any = ...
    def __init__(self, regex: typing.Union[str, bytes, typing.Pattern], flags: Any=..., *, error: str=...) -> None: ...
    def __call__(self, value: Any) -> typing.Any: ...

class Predicate(Validator):
    default_message: str = ...
    method: Any = ...
    error: Any = ...
    kwargs: Any = ...
    def __init__(self, method: str, *, error: str=..., **kwargs: Any) -> None: ...
    def __call__(self, value: Any) -> str: ...

class NoneOf(Validator):
    default_message: str = ...
    iterable: Any = ...
    values_text: Any = ...
    error: Any = ...
    def __init__(self, iterable: typing.Iterable, *, error: str=...) -> None: ...
    def __call__(self, value: Any) -> str: ...

class OneOf(Validator):
    default_message: str = ...
    choices: Any = ...
    choices_text: Any = ...
    labels: Any = ...
    labels_text: Any = ...
    error: Any = ...
    def __init__(self, choices: typing.Iterable, labels: typing.Iterable[str]=..., *, error: str=...) -> None: ...
    def __call__(self, value: Any) -> str: ...
    def options(self, valuegetter: typing.Union[str, typing.Callable[[typing.Any], typing.Any]]=...) -> typing.Iterable[typing.Tuple[typing.Any, str]]: ...

class ContainsOnly(OneOf):
    default_message: str = ...
    def __call__(self, value: Any) -> typing.Any: ...
